<!doctype html>
<link rel='import' href='bower_components/polymer/polymer-element.html'>
<script src='https://d3js.org/d3.v4.min.js'></script>

<!--
A chart that shows tasks as draggable dots

### Styling

The following custom properties are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--task-scheduler-background-color` | Color of the background | `#e0e0e0`
`--task-scheduler-today-line-color` | Color of the line indicating today | `#808080`
`--task-scheduler-valueline-color` | Color of the line connecting the dots | `#71af26`
`--task-scheduler-grid-color` | Color of the grid lines | `#d8d8d8`

### Example

```html
<d3-task-scheduler
	width="600"
	height="300"
	start="2018-01-01"
	deadlines="{'http://collaborne.com/schema/1.0/tasks/sensing': '2018-01-16','http://collaborne.com/schema/1.0/tasks/visioning': '2018-01-24','http://collaborne.com/schema/1.0/tasks/prototyping': '2018-01-31','http://collaborne.com/schema/1.0/tasks/scaling': '2018-02-08'}">
</d3-task-scheduler>
```

@demo demo/index.html
-->
<dom-module id='d3-task-scheduler'>
	<template>
		<style>
			:host {
				display: inline-block;
				background-color: var(--task-scheduler-background-color, #e0e0e0);
			}
			path {
				stroke-width: 2;
				fill: none;
			}
			.axis path,
			.axis line {
				fill: none;
				stroke: grey;
				stroke-width: 1;
				shape-rendering: crispEdges;
			}
			div.tooltip {
				position: absolute;
				text-align: center;
			}
			#today {
				stroke-width: 2;
				stroke: var(--task-scheduler-today-line-color, #808080);
			}
			#valueLine {
				fill: none;
				stroke: var(--task-scheduler-valueline-color, #71af26);
			}
			.label {
				margin-bottom: 16px;
			}

			.grid line {
				stroke: var(--task-scheduler-grid-color, #d8d8d8);
				stroke-opacity: 0.7;
				shape-rendering: crispEdges;
			}

			.grid path {
				stroke-width: 0;
			}
		</style>

		<svg id="svg" width$="[[width]]" height$="[[height]]">
			<g transform$="[[_transform]]">
				<line id="today"></line>
				<path id="valueLine"></path>
				<g class="grid"></g>
				<g id="xAxis"></g>
				<g id="yAxis"></g>
			</g>
		</svg>
	</template>

	<script>
		/**
		 * @customElement
		 * @polymer
		 */
		class D3TaskScheduler extends Polymer.Element {

			static get is() {
				return 'd3-task-scheduler';
			}

			constructor() {
				super();
			}

			static get properties() {
				return {
					/**
					* Object that maps task name to scheduled deadline
					*/
					deadlines: Object,
					/**
					* String representing the first day of the schedule in the format yyyy-mm-dd
					*/
					start: String,
					/**
					* Component width
					*/
					width: Number,
					/**
					* Component height
					*/
					height: Number,
					end: {
						type: String,
						computed: '_computeEnd(deadlines)'
					},
					margin: {
						type: Object,
						value: {
							top: 30,
							right: 50,
							bottom: 30,
							left: 50
						}
					},
					// Functions to calculate ranges
					x: {
						type: Number,
						computed: '_computeXRange(start, end, width, margin)'
					},
					y: {
						type: Number,
						computed: '_computeYRange(height, margin)'
					},
					// Graph dimensions
					_graphWidth: {
						type: Number,
						computed: '_computeGraphWidth(width, margin)'
					},
					_graphHeight: {
						type: Number,
						computed: '_computeGraphHeight(height, margin)'
					},
					_transform: {
						type: String,
						computed: '_computeTransform(margin)'
					},
				};
			}

			static get observers() {
				return [
					'_drawXAxis(x)',
					'_drawYAxis(y)',
					'_drawTodayLine(x)',
					'_drawXGridlines(x)',
				];
			}

			_computeEnd(deadlines) {
				const taskIds = Object.keys(this.deadlines);
				const lastTaskId = taskIds[taskIds.length - 1];
				return this.deadlines[lastTaskId];
			}

			_computeTransform(margin) {
				return `translate(${margin.left}, ${margin.top})`;
			}

			_computeGraphWidth(width, margin) {
				return width - margin.left - margin.right;
			}

			_computeGraphHeight(height, margin) {
				return height - margin.top - margin.bottom;
			}

			_computeXRange(start, end, width, margin) {
				// Expand time limit for the end of 1 month and a half, so that last dot is 
				// draggable after the scheduled end of the project
				const endMonth = new Date(end).getMonth();
				const expandedEnd = new Date(end).setMonth(endMonth + 1.5);
				return d3.scaleTime()
					.domain([new Date(start), expandedEnd])
					.range([0, width - margin.left - margin.right]);
			}

			_computeYRange(height, margin) {
				return d3.scaleLinear()
					.domain([0, 100])
					.range([height - margin.top - margin.bottom, 0]);
			}

			_drawXAxis(x) {
				const xAxis = d3.axisBottom(x).ticks(d3.timeMonth).tickFormat(d3.timeFormat('%B'));
				d3.select(this.$.xAxis)
					.attr('class', 'x axis')
					// By default x axis is on the upperside
					// so we need to move it down by the graph height
					.attr('transform', 'translate(0,' + this._graphHeight + ')')
					.call(xAxis);
			}

			_drawYAxis(y) {
				const yAxis = d3.axisLeft(y);
				d3.select(this.$.yAxis)
					.attr('class', 'y axis')
					.call(yAxis);
			}

			_drawValuelinePath() {
				d3.select(this.$.valueLine)
					.attr('class', 'line')
					.attr('d', this._valueline(this._inputData));
			}

			buildInputData() {
				const projectTotalDuration = new Date(this.end).getTime() - new Date(this.start).getTime();
				const parseDate = d3.timeParse('%Y-%m-%d');
				this._inputData = Object.keys(this.deadlines).map(taskId => {
					const phaseDeadline = this.deadlines[taskId];
					// Progress is relative weight of the phase compared to the total project duration
					const progress = (new Date(phaseDeadline).getTime() - new Date(this.start).getTime()) / projectTotalDuration;
					return {
						// Define name of the element as the last word in the phase id
						// eg. for 'http://collaborne.com/schema/1.0/tasks/sensing' extracts name 'sensing'
						name: taskId.split(/[/ ]+/).pop(),
						taskId,
						date: parseDate(phaseDeadline),
						progress,
						percentage: +(progress * 100)
					};
				});
				// Add also one dot representing the start
				this._inputData.unshift({
					name: 'start',
					taskId: 'start',
					date: new Date(this.start),
					progress: 0,
					percentage: 0,
				});
			}

			_drawTodayLine(x) {
				// Add vertical line on today's date
				const todayDate = new Date();
				const todayXCoordinate = x(todayDate);
				d3.select(this.$.today)
					.attr('x1', todayXCoordinate)
					.attr('y1', 0)
					.attr('x2', todayXCoordinate)
					.attr('y2', this._graphHeight);
			}

			addTooltip(d) {
				const buildTooltipText = d => {
					const format = d3.timeFormat('%d-%m-%Y');
					return `${d.name}: ${format(new Date(d.date))}`;
				};
				d3.select(this.$.svg).append('text')
					.attr('class', 'tooltip')
					.text(buildTooltipText(d))
					.attr('x', this.x(d.date))
					// Position tooltip under the dot so that it's readable
					.attr('y', this.y(d.percentage) + 72);
			}

			removeTooltip() {
				d3.select(this.$.svg).selectAll('.tooltip').remove();
			}

			_valueline(data) {
				return d3.line().x(d => this.x(d.date)).y(d => this.y(d.percentage))(data);
			}

			_drawScatterPlot() {
				const dragged = d => {
					const todayDate = new Date();
					// Allow post-poning deadlines only after today
					// and not after the graph X edge
					const endMonth = new Date(this.end).getMonth();
					const expandedEnd = new Date(this.end).setMonth(endMonth + 1.5);
					if (d.date >= todayDate && d.date < expandedEnd) {
						// Save previous deadline value
						const oldDeadline = d.date;
						// Update the date for the dragged task
						d.date = this.x.invert(d3.event.x);
						// Save time delta
						const timeDelta = d.date - oldDeadline;
						// Move the current dot
						d3.select(this.$.svg)
							.select(`.${d.name}`)
							.attr('cx', this.x(d.date));

						// Trigger schedule recalculation if dot is moved forward
						if (timeDelta > 0) {
							const taskIndex = this._inputData.indexOf(d);
							this._recalculateSchedule(taskIndex, timeDelta);
						}

						// Move also other dots
						this._inputData.forEach(taskItem => {
							d3.select(this.$.svg)
								.select(`.${taskItem.name}`)
								.attr('cx', this.x(taskItem.date));
						});

						// Redraw line connecting dots
						this._drawValuelinePath();

						// Redraw dot labels
						this._redrawLabels();
					}
				};

				d3.select(this.$.svg).select('g').selectAll('dot')
					.data(this._inputData)
					.enter().append('circle')
					// Define class of the circle as the phase name
					.attr('class', d => d.name)
					.attr('r', 8)
					.attr('cx', d => {
						return this.x(d.date);
					})
					.attr('cy', d => {
						return this.y(d.percentage);
					})
					.on('mouseover', d => this.addTooltip(d))
					.on('mouseout', () => this.removeTooltip())
					.style('fill', d => {
						switch(d.name){
							case 'sensing':
								return 'blue';
							case 'visioning':
								return 'red';
							case 'prototyping':
								return 'yellow';
							case 'scaling':
								return 'green';
							default:
								return 'grey';
						}
					})
					.call(d3.drag().on('drag', dragged));
			}

			_drawLabels() {
				d3.select(this.$.svg).select('g').selectAll('dot')
					.data(this._inputData)
					.enter().append('text')
					.attr('class', 'label')
					.attr('x', d => this.x(d.date) - 16)
					.attr('y', d => this.y(d.percentage) - 16)
					.text(d => `${Math.round(d.progress * 100)} %`);
			}

			_redrawLabels() {
				d3.select(this.$.svg).select('g').selectAll('text.label')
					.attr('x', d => this.x(d.date) - 16);
			}

			_recalculateSchedule(taskIndex, timeDelta) {
				const format = d3.timeFormat('%Y-%m-%d');
				this._inputData
					// Consider only tasks after the one dragged
					.filter(item => this._inputData.indexOf(item) > taskIndex)
					// Move date for them too
					.map(taskItem => {
						const previousDeadline = new Date(taskItem.date);
						taskItem.date = new Date(previousDeadline).getTime() + timeDelta;
					});
			}

			_drawXGridlines(x) {
				d3.select(this.$.svg).selectAll('.grid')
					.attr('transform', 'translate(0,' + this._graphHeight + ')')
					.call(d3.axisBottom(x)
						.ticks(d3.timeMonth)
						.tickSize(-this._graphHeight)
						.tickFormat('')
					);
			}

			ready() {
				super.ready();
				// Define data to build the graphics
				this.buildInputData();

				this._drawScatterPlot();

				this._drawLabels();

				this._drawValuelinePath();
			}
		}
		customElements.define(D3TaskScheduler.is, D3TaskScheduler);
	</script>
</dom-module>
