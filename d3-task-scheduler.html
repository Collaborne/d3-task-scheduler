<!doctype html>
<link rel="import" href="../polymer/polymer-element.html">
<script src="../d3/d3.min.js"></script>

<!--
A chart that shows tasks as draggable dots

### Styling

The following custom properties are available for styling:

Custom property                       | Description                                              | Default
--------------------------------------|----------------------------------------------------------|----------
`--task-scheduler-background-color`   | Color of the background                                  | `#e0e0e0`
`--task-scheduler-area-color`         | Color of the background of the graph under the valueline | `#f6faf6`
`--task-scheduler-footer-color`       | Color of the background of footer                        | `#bfbfbf`
`--task-scheduler-today-marker-color` | Color of the marker indicating today                     | `#E30B5C`
`--task-scheduler-dots-color`         | Color of the dots and the line connecting them           | `#71af26`
`--task-scheduler-grid-color`         | Color of the grid lines                                  | `#d8d8d8`
`--task-scheduler-axis-color`         | Color of the axis, including axis line, ticks and labels | `#666666`
`--task-scheduler-font-family`        | Font family for the text parts                           | `sans-serif`
`--task-scheduler-label-size`         | Font size for graph labels                               | `8px`

### Example

```html
<d3-task-scheduler
	height="300"
	start="2018-01-01"
	deadlines="[[deadlines]]">
</d3-task-scheduler>
```

@demo demo/index.html
-->
<dom-module id="d3-task-scheduler">
	<template>
		<style>
			:host {
				display: inline-block;
				background-color: var(--task-scheduler-background-color, #e0e0e0);
				font-family: var(--task-scheduler-font-family, "sans-serif");
			}
			path {
				stroke-width: 2;
				fill: none;
			}
			.axis {
				font-family: var(--task-scheduler-font-family, "sans-serif");
			}
			.axis path,
			.axis line {
				fill: none;
				stroke: var(--task-scheduler-axis-color, #666666);
				stroke-width: 1;
				shape-rendering: crispEdges;
			}
			.axis text {
				fill: var(--task-scheduler-axis-color, #666666);
			}
			.tooltip {
				position: absolute;
				text-align: center;
				fill: var(--task-scheduler-axis-color, #666666);
				font-size: var(--task-scheduler-label-size, 10px);
			}
			#today {
				stroke-width: 2;
				stroke: var(--task-scheduler-today-line-color, #808080);
			}
			#valueLine {
				fill: none;
				stroke: var(--task-scheduler-dots-color, #71af26);
			}
			circle {
				fill: var(--task-scheduler-dots-color, #71af26);
			}
			.draggable {
				stroke: #fff;
				stroke-width: 2;
			}
			#area {
				fill: var(--task-scheduler-area-color, #f6faf6);
			}
			.label {
				fill: var(--task-scheduler-axis-color, #666666);
				font-size: var(--task-scheduler-label-size, 10px);
			}
			.grid line {
				stroke: var(--task-scheduler-grid-color, #d8d8d8);
				stroke-opacity: 0.7;
				shape-rendering: crispEdges;
			}
			.grid path {
				stroke-width: 0;
			}
			.footer {
				fill: var(--task-scheduler-footer-color, #bfbfbf);
			}
		</style>

		<svg id="svg" width$="[[width]]" height$="[[height]]">
			<rect class="footer"></rect>
			<g transform$="[[_transform]]">
				<path id="area"></path>
				<line id="today"></line>
				<path id="valueLine"></path>
				<g class="grid"></g>
				<g id="xAxis"></g>
				<g id="yAxis"></g>
			</g>
		</svg>
	</template>

	<script>
		/**
		 * @customElement
		 * @polymer
		 */
		class D3TaskScheduler extends Polymer.Element {

			static get is() {
				return 'd3-task-scheduler';
			}

			constructor() {
				super();
			}

			static get properties() {
				return {
					/**
					* Array of tasks
					*/
					deadlines: Array,
					/**
					* String representing the first day of the schedule in the format yyyy-mm-dd
					*/
					start: String,
					/**
					* Component width
					*/
					width: {
						type: Number,
						computed: '_computeWidth()'
					},
					/**
					* Component height
					*/
					height: {
						type: Number,
						value: 350,
					},
					end: {
						type: String,
						computed: '_computeEnd(deadlines)'
					},
					margin: {
						type: Object,
						value: {
							top: 30,
							right: 50,
							bottom: 50,
							left: 50
						}
					},
					// Functions to calculate ranges
					x: {
						type: Number,
						computed: '_computeXRange(start, end, width, margin)'
					},
					y: {
						type: Number,
						computed: '_computeYRange(height, margin)'
					},
					// Graph dimensions
					_graphWidth: {
						type: Number,
						computed: '_computeGraphWidth(width, margin)'
					},
					_graphHeight: {
						type: Number,
						computed: '_computeGraphHeight(height, margin)'
					},
					_transform: {
						type: String,
						computed: '_computeTransform(margin)'
					},

					_tasks: {
						type: Array,
						computed: '_computeTasks(start, end, deadlines)',
					},
				};
			}

			static get observers() {
				return [
					'_drawXAxis(x, _graphHeight)',
					'_drawYAxis(y, _tasks)',
					'_drawTodayMarker(x, _graphHeight)',
					'_drawXGridlines(x, _graphHeight)',
					'_drawScatterPlot(_tasks)',
					'_drawLabels(_tasks)',
					'_drawValuelinePath(_tasks)',
					'_drawColouredArea(_tasks, _graphHeight)',
					'_drawColouredFooter(width, _graphHeight)',
				];
			}

			_computeWidth() {
				return document.body.clientWidth;
			}

			_computeEnd(deadlines) {
				if (!deadlines || deadlines.length === 0) {
					return;
				}

				const lastDeadline = deadlines[deadlines.length - 1];
				return lastDeadline.date;
			}

			_computeTransform(margin) {
				return `translate(${margin.left}, ${margin.top})`;
			}

			_computeGraphWidth(width, margin) {
				return width - margin.left - margin.right;
			}

			_computeGraphHeight(height, margin) {
				return height - margin.top - margin.bottom;
			}

			_computeXRange(start, end, width, margin) {
				// Expand time limit for the end of 1 month and a half, so that last dot is 
				// draggable after the scheduled end of the project
				const endMonth = new Date(end).getMonth();
				// X edge is the maximum date between today and end of the project plus 1.5 months
				const xEdge = Math.max(new Date(), new Date(end).setMonth(endMonth + 1.5));
				return d3.scaleTime()
					.domain([new Date(start), xEdge])
					.range([0, width - margin.left - margin.right]);
			}

			_computeYRange(height, margin) {
				return d3.scaleLinear()
					.domain([0, 100])
					.range([height - margin.top - margin.bottom, 0]);
			}

			_drawXAxis(x, graphHeight) {
				const xAxis = d3.axisBottom(x).ticks(d3.timeMonth).tickFormat(d3.timeFormat('%B'));
				d3.select(this.$.xAxis)
					.attr('class', 'x axis')
					// By default x axis is on the upperside
					// so we need to move it down by the graph height
					.attr('transform', 'translate(0,' + graphHeight + ')')
					.call(xAxis);
			}

			_drawYAxis(y, tasks) {
				const yValues = tasks.map(task => task.percentage);
				const yAxis = d3.axisLeft(y).tickFormat('').tickValues(yValues).tickSizeInner([-16]);
				d3.select(this.$.yAxis)
					.attr('class', 'y axis')
					.call(yAxis);
			}

			_drawValuelinePath(tasks) {
				d3.select(this.$.valueLine)
					.attr('class', 'line')
					.attr('d', this._valueline(tasks));
			}

			_drawColouredArea(tasks, graphHeight) {
				const area = d3.area()
					.x(task => this.x(task.date))
					.y0(graphHeight)
					.y1(task => this.y(task.percentage));
				d3.select(this.$.area).attr('d', area(tasks));
			}

			_computeTasks(start, end, deadlines) {
				if (!start || !end || !deadlines) {
					return;
				}
				const projectTotalDuration = new Date(end).getTime() - new Date(start).getTime();
				const parseDate = d3.timeParse('%Y-%m-%d');
				const taskDots = deadlines.map(deadline => {
					// Progress is relative weight of the phase compared to the total project duration
					const progress = (new Date(deadline.date).getTime() - new Date(start).getTime()) / projectTotalDuration;
					return {
						name: deadline.name,
						taskId: deadline.taskId,
						date: parseDate(deadline.date),
						progress,
						percentage: 100 * progress,
					};
				});
				// Add also one dot representing the start
				const startDot = {
					name: 'start',
					taskId: 'start',
					date: new Date(start),
					progress: 0,
					percentage: 0,
				};

				return [
					startDot,
					...taskDots,
				];
			}

			_drawTodayMarker(x, graphHeight) {
				// Add marker to x axis corresponding to today
				const todayDate = new Date();
				// Default dimension for the marker is 30px
				const imageSize = 30;
				d3.select(this.$.svg).select('g').selectAll('tod')
					.data([todayDate])
					.enter().append('image')
					// Location icon encoded as base64 SVG
					.attr('xlink:href', 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNG1tIiBoZWlnaHQ9IjI0bW0iIHZpZXdCb3g9IjAgMCAyNCAyNCI+PGc+PHBhdGggZmlsbD0iI2Q4MWI2MCIgZD0iTTEyIDJDOC4xMyAyIDUgNS4xMyA1IDljMCA1LjI1IDcgMTMgNyAxM3M3LTcuNzUgNy0xM2MwLTMuODctMy4xMy03LTctN3ptMCA5LjVjLTEuMzggMC0yLjUtMS4xMi0yLjUtMi41czEuMTItMi41IDIuNS0yLjUgMi41IDEuMTIgMi41IDIuNS0xLjEyIDIuNS0yLjUgMi41eiIvPjwvZz48L3N2Zz4=')
					.attr('height', imageSize)
					.attr('width', imageSize)
					// The center of the pin is at half of its size
					.attr('x', d => this.x(d) - (imageSize / 2))
					.attr('y', graphHeight - imageSize);
			}

			toTooltipText(date) {
				const format = d3.timeFormat('%d %B %Y');
				return `${format(new Date(date))}`;
			};

			addTooltip(task) {
				d3.select(this.$.svg).append('text')
					.attr('class', 'tooltip')
					.text(this.toTooltipText(task.date))
					.attr('x', this.x(task.date))
					// Position tooltip above the dot so that it's readable
					.attr('y', this.y(task.percentage) + 16);
			}

			removeTooltip() {
				d3.select(this.$.svg).selectAll('.tooltip').remove();
			}

			updateTooltip(task) {
				d3.select(this.$.svg).select('.tooltip')
					.text(this.toTooltipText(task.date))
					.attr('x', this.x(task.date));
			}

			_valueline(data) {
				return d3.line()
					.x(task => this.x(task.date))
					.y(task => this.y(task.percentage))
					(data);
			}

			_isAfter(date1, date2) {
				const dayDate1 = new Date(date1).setHours(0, 0, 0, 0);
				const dayDate2 = new Date(date2).setHours(0, 0, 0, 0);
				return dayDate1 > dayDate2;
			}

			_isEqual(date1, date2) {
				const dayDate1 = new Date(date1).setHours(0, 0, 0, 0);
				const dayDate2 = new Date(date2).setHours(0, 0, 0, 0);
				return dayDate1 === dayDate2;
			}

			_drawScatterPlot(tasks) {
				if (!tasks) {
					return;
				}
				const dragged = task => {
					const todayDate = new Date();

					const index = tasks.indexOf(task);
					// Dates can only be moved between the surrounding dots
					let minDate;
					if (index > 0) {
						minDate = tasks[index -1].date;
					} else {
						minDate = this.start;
					}

					let maxDate;
					if (index < tasks.length - 1) {
						// Only allow moving until the next task
						maxDate = tasks[index + 1].date;
					} else {
						// Allow post-poning deadlines only after today
						// and not after the graph X edge
						const endMonth = new Date(this.end).getMonth();
						maxDate = new Date(this.end).setMonth(endMonth + 1.5);
					}

					// Check date which the dot has been dragged to
					const futureDate = this.x.invert(d3.event.x);
					if ((this._isEqual(futureDate, todayDate) || this._isAfter(futureDate, todayDate)) && this._isAfter(futureDate, minDate) && this._isAfter(maxDate, futureDate)) {
						// Update the date for the dragged task
						task.date = futureDate;
						// Move the current dot
						d3.select(this.$.svg)
							.select(`.${task.name}`)
							.attr('cx', this.x(task.date));

						// Redraw line connecting dots
						this._drawValuelinePath(tasks);

						// Redraw dot labels
						this._updateLabels();

						// Redraw coloured area below value line
						this._drawColouredArea(tasks, this._graphHeight);

						// Update tooltip when the dot is dragged
						this.updateTooltip(task);
					}
				};

				d3.select(this.$.svg).select('g').selectAll('dot')
					.data(tasks)
					.enter().append('circle')
					// Define class of the circle as the phase name
					// plus 'draggable' to apply different styles
					.attr('class', task => {
						const todayDate = new Date();
						if (this._isAfter(task.date, todayDate)) {
							return `${task.name} draggable`;
						}
						return task.name;
					})
					.attr('r', 8)
					.attr('cx', task => this.x(task.date))
					.attr('cy', task => this.y(task.percentage))
					.on('mouseover', task => this.addTooltip(task))
					.on('mouseout', () => this.removeTooltip())
					.call(d3.drag().on('drag', dragged));
			}

			_drawLabels(tasks) {
				if (!tasks) {
					return;
				}
				d3.select(this.$.svg).select('g').selectAll('dot')
					.data(tasks)
					.enter().append('text')
					.attr('class', 'label')
					.attr('x', task => this.x(task.date))
					.attr('y', task => this.y(task.percentage) + 32)
					.append('tspan')
					.attr('dy', 0)
					.attr('x', task => this.x(task.date) - 16)
					.text(task => task.name)
					.append('tspan')
					// Offset by 1.2 em
					.attr('dy', '1.2em')
					.attr('x', task => this.x(task.date) - 16)
					.text(task => `${Math.round(task.progress * 100)}% progress`);
			}

			_updateLabels() {
				d3.select(this.$.svg).select('g').selectAll('text.label tspan')
					.attr('x', task => this.x(task.date) - 16);
			}

			_drawXGridlines(x, graphHeight) {
				d3.select(this.$.svg).selectAll('.grid')
					.attr('transform', 'translate(0,' + graphHeight + ')')
					.call(d3.axisBottom(x)
						.ticks(d3.timeMonth)
						.tickSize(-graphHeight)
						.tickFormat('')
					);
			}

			_drawColouredFooter(width, graphHeight) {
				d3.select(this.$.svg).select('.footer')
						.attr('x', 0)
						.attr('y', graphHeight + this.margin.top)
						.attr('width', width)
						.attr('height', this.margin.bottom);
			}
		}
		customElements.define(D3TaskScheduler.is, D3TaskScheduler);
	</script>
</dom-module>
